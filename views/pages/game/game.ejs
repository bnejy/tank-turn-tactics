<%- include('../../partials/head.html') %>

<style>
    body {
        background: none
    }
</style>

<body>

<div id="statsPanel">

</div>

<div id="gameContainer"></div>

<div id="winScreen" class="panel">
    <h1>Mission Complete</h1>
    <p></p>
    <a href="/">Return to menu</a>
</div>

<div id="infoPanel" class="panel">
    <h3 id="name"></h3>
    <p id="id"></p>

    <p id="actions"></p>
    <div class="upgrade" data-upgrade="health" data-cost=2>
        <span id="health"></span>
        <span class="actionsToAdd"></span>
        <span><a class="minus">-</a><a class="plus">+</a></span>
    </div>
    <div class="upgrade" data-upgrade="range" data-cost=1>
        <span id="range"></span>
        <span class="actionsToAdd"></span>
        <span><a class="minus">-</a><a class="plus">+</a></span>
    </div>

    <span class="confirm"><a class="cancel">✘</a><a class="confirm">✓</a></span>

</div>

<div id="hintPanel" class="panel">
    <h3></h3>
    <p></p>
    <p id="minorHint"></p>
</div>

<script type="text/javascript" src="js/game-engine/Game.js"></script>

<script>
    let game = JSON.parse('<%- JSON.stringify(game) %>')
    let userPlayer = game.players.find(player => player.user_id === game.user_id)

    game.players = game.players.filter(p => p.health > 0)

    let gameOver = false;
    const isDead = userPlayer.health <= 0;

    if (game.players.filter(player => player.health > 0).length <= 1) {
        gameOver = true;

        document.querySelector("#winScreen").style.display = 'block'
        document.querySelector("#winScreen p").innerHTML = game.players.find(player => player.health > 0).name + " has emerged victorious"
    }

    const size = game.size
    const GRID_SIZE = 50;

    const giveRangeIncrease = 2;

    // Scores
    let actions = userPlayer.actions

    const upgradeButtons = []

    // Colors
    const c_gridLabel = 'rgba(255,255,255,0.46)';
    const c_gridLabelSelected = 'rgb(117,255,234)';

    const c_playerRange = 'rgb(117,255,234)'
    const c_enemyRange = '#ff0000'

    const c_moveBlock = 'rgba(101,249,255,0.21)'
    const c_moveCancel = 'rgba(255,242,101,0.2)'
    const c_moveOutOfRange = 'rgba(255,0,0,0.29)'
    const c_moveLine = '#60d5ff'
    const c_atkRange = 'rgba(255,0,0,0.88)'
    const c_giveRange = 'rgba(121,255,113,0.84)'

    const c_atkTarget = '#ffd271'
    const c_atkMarkedTarget = '#ff0000'
    const c_atkConfirming = 'rgba(255,0,0,0.33)'

    const c_giveLine = '#73f56b'
    const c_giveConfirming = 'rgba(115,245,107,0.3)'


    // Set up
    const parentDiv = document.querySelector('#gameContainer')
    const gridPadding = GRID_SIZE * 2;
    const footerPadding = 100;
    const rightPadding = 300;
    const gameDim = {
        width: size.width * GRID_SIZE + gridPadding + rightPadding,
        height: size.height * GRID_SIZE + gridPadding + footerPadding
    }

    // Fetching
    function refetch() {
        return fetch(`/game/${ game._id }`, { method: "GET" })
            .then(res => res.json())
            .then(newGame => {
                game = newGame;
                game.players = game.players.filter(p => p.health > 0)
                userPlayer = game.players.find(player => player.user_id === game.user_id)
                actions = userPlayer.actions
                updateTanks()
                updateInfo()
                actionGuis.forEach(gui => gui.init())

                if (game.players.filter(player => player.health > 0).length <= 1) {
                    gameOver = true;

                    document.querySelector("#winScreen").style.display = 'block'
                    document.querySelector("#winScreen p").innerHTML = game.players.find(player => player.health > 0).name + " has emerged victorious"
                }
            })
    }

    const backgroundDriver = initDriver(parentDiv, Driver.MODE_PASSIVE, gameDim)
    backgroundDriver.canvas_ctx.save()
    backgroundDriver.canvas_ctx.font = '12px Arial'

    let focused = false;
    let showPlayerOption = !gameOver && userPlayer.actions > 0;
    let hoveredBox = { x: GRID_SIZE, y: GRID_SIZE, coords: { x: 0, y: 0 } }

    if (gameOver) {
        hoveredBox = { x: -100, y: -100, coords: { x: -1, y: -1 } }
    }

    class GridBox extends Driver.PassiveComponent {
        constructor(coords, x, y, width, height, color) {
            super();
            this.borderColor = color;

            this.coords = coords;
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
        }

        onMouseEvent = (driver, e) => {
            if (gameOver) {
                hoveredBox = { x: -100, y: -100, coords: { x: -1, y: -1 } }
            }

            if (inBounds({ x: e.offsetX, y: e.offsetY }, this)) {
                hoveredBox = this;
            }
        }

        redraw = driver => {
            const ctx = driver.canvas_ctx;
            ctx.lineWidth = 1;
            ctx.strokeStyle = this.borderColor
            ctx.strokeRect(this.x, this.y, this.width, this.height)
        }
    }

    const grid = [];
    for (let i = 0; i < size.width; i++) {
        grid.push([])
        for (let j = 0; j < size.height; j++) {
            const gridBox = new GridBox({
                x: i,
                y: j
            }, gridPadding + i * GRID_SIZE, gridPadding + j * GRID_SIZE, GRID_SIZE, GRID_SIZE, (i + j) % 2 === 0 ? 'rgba(7,129,0,0.4)' : 'rgba(52,52,52,0.11)');

            grid[i].push(gridBox)
            backgroundDriver.components.push(gridBox)
        }
    }

    // Grid labels
    backgroundDriver.components.push(new class extends Driver.PassiveComponent {
        redraw = driver => {
            driver.canvas_ctx.textAlign = 'center'

            // Selected position
            const pos = selectedTank.player.position;

            for (let i = 0; i < game.size.height; i++) {
                driver.canvas_ctx.fillStyle = pos.y === i ? c_gridLabelSelected : c_gridLabel
                driver.canvas_ctx.fillText(`${ i + 1 }`,
                    gridPadding - GRID_SIZE + GRID_SIZE / 2,
                    i * GRID_SIZE + GRID_SIZE / 2 + gridPadding)
            }
            for (let i = 0; i < game.size.width; i++) {
                driver.canvas_ctx.fillStyle = pos.x === i ? c_gridLabelSelected : c_gridLabel
                driver.canvas_ctx.fillText(getChar(i),
                    i * GRID_SIZE + GRID_SIZE / 2 + gridPadding,
                    gridPadding - GRID_SIZE + GRID_SIZE / 2)
            }
        }
    })

    const objectDriver = initDriver(parentDiv, Driver.MODE_ACTIVE, gameDim)
    objectDriver.canvas_ctx.save();
    objectDriver.canvas_ctx.font = 'bold 15px Uni-Sans'

    let selectedTank = null;
    const ACTION_STATES = {
        SELECT: "select",
        ATK: "attack",
        MV: "move",
        GV: "give"
    }
    let actionState = ACTION_STATES.SELECT;

    class Tank extends Driver.ActiveComponent {
        constructor(player) {
            super();
            this.player = player
            this.box = this.player.box

            this.move(player.position)
        }

        refetch(player) {
            this.player = player
            this.box = this.player.box
            this.move(this.player.position)
        }

        move(pos) {
            this.box = grid[pos.x][pos.y];

            this.x = this.box.x;
            this.y = this.box.y;
            this.width = this.box.width;
            this.height = this.box.height;
        }

        update(driver) {
            // Player selection
            if (driver.mouse_events.pressed) {
                if (inBounds(driver.mouse_events, this) && actionState === ACTION_STATES.SELECT && !gameOver) {
                    if (actionPopups.some(action => action.hover)) return

                    showPlayerOption = !showPlayerOption

                    if (selectedTank !== userTank) {
                        showPlayerOption = true;
                    }

                    selectedTank = this;

                    if (selectedTank === userTank) {
                        enableUpgrades()
                    } else {
                        disableUpgrades()
                    }

                    if (userPlayer.actions <= 0) showPlayerOption = false;
                    updateInfo()
                }
            }
        }

        /**
         * @param {CanvasRenderingContext2D} ctx
         * @param {string} color
         */
        drawTriangle(ctx, color) {
            const padding = this.width / 6;
            const center = { x: this.x + this.width / 2, y: this.y + padding };
            const left = { x: this.x + padding, y: this.y + this.height - padding }
            const right = { x: this.x + this.width - padding, y: this.y + this.height - padding }

            ctx.beginPath();
            ctx.moveTo(center.x, center.y);
            ctx.lineTo(right.x, right.y)
            ctx.lineTo(left.x, left.y)
            ctx.lineTo(center.x, center.y)
            ctx.closePath();
            ctx.strokeStyle = color
            ctx.lineWidth = 2
            ctx.setLineDash([])
            ctx.stroke();
            ctx.lineWidth = 1
        }

        redraw(driver) {
            const ctx = driver.canvas_ctx;
            const color = this.player.user_id === game.user_id ? 'rgb(0,255,195)' : 'rgb(255,65,65)'
            ctx.shadowColor = 'transparent'

            // Name
            if (!(actionState !== ACTION_STATES.SELECT && this === userTank)) {
                ctx.fillStyle = selectedTank === this ? 'white' : 'rgba(255,255,255,0.45)'
                ctx.textAlign = 'center'
                ctx.fillText(this.player.name, this.x + this.width / 2, this.y + this.height + 12)
                ctx.fillText(this.player.health, this.x + this.width / 2, this.y - 10)
            }


            if (selectedTank === this && actionState === ACTION_STATES.SELECT) {
                ctx.shadowColor = 'white'
                ctx.shadowBlur = 10;

                // Selection lines
                ctx.beginPath();
                ctx.moveTo(gridPadding, this.y + this.height / 2)
                ctx.lineTo(this.x, this.y + this.height / 2)
                ctx.moveTo(this.x + this.width, this.y + this.height / 2)
                ctx.lineTo(gameDim.width - rightPadding, this.y + this.height / 2)

                ctx.moveTo(this.x + this.width / 2, gridPadding)
                ctx.lineTo(this.x + this.width / 2, this.y)
                ctx.moveTo(this.x + this.width / 2, this.y + this.height)
                ctx.lineTo(this.x + this.width / 2, gameDim.height - footerPadding)
                ctx.setLineDash([])
                ctx.strokeStyle = 'rgba(14,255,229,0.55)'
                ctx.stroke()
            }

            if (selectedTank === this || actionState === ACTION_STATES.MV) {
                let center = this

                if (actionState === ACTION_STATES.MV && this === userTank) {
                    center = hoveredBox
                }

                if (actionState === ACTION_STATES.SELECT || actionState === ACTION_STATES.MV || actionState === ACTION_STATES.ATK) {

                    ctx.beginPath()
                    ctx.arc(center.x + this.width / 2, center.y + this.height / 2, this.player.range * this.width + this.width / 2, 0, 2 * Math.PI)
                    if (this.player === userPlayer) {

                        if (actionState === ACTION_STATES.ATK) {
                            if (attackGui.selectedTarget) {
                                ctx.strokeStyle = c_atkMarkedTarget
                            } else {
                                ctx.strokeStyle = c_atkTarget
                            }
                        } else {
                            ctx.strokeStyle = c_playerRange
                        }
                    } else {
                        ctx.strokeStyle = c_enemyRange
                    }

                    if (actionState === ACTION_STATES.MV) {
                        ctx.strokeStyle = "rgba(255,255,255,0.19)"
                    }

                    ctx.setLineDash([ 15, 10 ])
                    ctx.stroke()

                }

                if (actionState === ACTION_STATES.SELECT || actionState === ACTION_STATES.GV) {
                    // Give range
                    ctx.beginPath()
                    ctx.arc(center.x + this.width / 2, center.y + this.height / 2, (this.player.range + giveRangeIncrease) * this.width + this.width / 2, 0, 2 * Math.PI)
                    ctx.strokeStyle = "rgba(88,255,81,0.16)"
                    ctx.setLineDash([ 5, 2 ])
                    ctx.stroke()
                }
            }
            this.drawTriangle(ctx, color)
        }
    }

    const tanks = game.players.map(player => new Tank(player))
    tanks.forEach(t => objectDriver.components.push(t))

    function updateTanks() {
        tanks.map(tank => {
            const player = game.players.find(player => player._id === tank.player._id);
            if (player) {
                tank.refetch(player)
            } else {
                objectDriver.components.splice(objectDriver.components.indexOf(tank), 1)
                tanks.splice(objectDriver.components.indexOf(tank), 1)
            }
        })
    }

    let userTank = objectDriver.components.find(tank => tank.player.user_id === game.user_id) // Init selected tank

    if (!isDead) {
        selectedTank = userTank
    } else {
        selectedTank = tanks[0]
    }

    const guiDriver = initDriver(parentDiv, Driver.MODE_ACTIVE, gameDim)


    class ActionPopup extends Driver.ActiveComponent {
        constructor(text, xOffset, textAlign, state, color = '#fcda6d') {
            super();

            this.userTank = userTank
            this.show = false;
            this.hover = false;
            this.selected = false;

            this.yLevel = 75;
            this.yOffset = 10;
            this.xOffset = xOffset;
            this.height = 20;
            this.color = color

            this.text = text;
            this.textAlign = textAlign;
            this.state = state;

            this.font = `${ this.height }px Uni-Sans`;

            this.bounds = null;
        }

        update(driver) {
            this.show = selectedTank.player.user_id === userPlayer.user_id && showPlayerOption && actionState === ACTION_STATES.SELECT;

            if (!this.show) return;

            const ctx = driver.canvas_ctx;

            ctx.textAlign = this.textAlign
            ctx.font = this.font

            this.bounds = {
                x: userTank.x + this.xOffset + userTank.width / 2 - ctx.measureText(this.text).actualBoundingBoxLeft - 10,
                y: userTank.y + this.yLevel - this.yOffset,
                width: ctx.measureText(this.text).width + 18,
                height: this.height + this.yOffset * 2
            }

            this.hover = inBounds(driver.mouse_events, this.bounds)
            focused = this.hover || focused

            if (this.hover && driver.mouse_events.pressed) {
                actionState = this.state;
                driver.mouse_events.pressed = false;
                attackGui.init()
            }
        }

        redraw(driver) {
            if (!this.show) return;
            const ctx = driver.canvas_ctx;

            const x = userTank.x + this.xOffset + userTank.width / 2;
            const y = userTank.y + this.yLevel;

            ctx.textAlign = this.textAlign
            ctx.textBaseline = 'hanging'
            ctx.font = this.font

            ctx.fillStyle = 'rgba(0,0,0,0.47)'
            ctx.fillRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height)

            if (this.hover) {
                ctx.strokeStyle = this.color
                ctx.strokeText(this.text, x, y)
            }

            ctx.fillStyle = 'white'
            ctx.fillText(this.text, x, y)
        }
    }

    const xOffset = 50;

    const moveButton = new ActionPopup("Move", -xOffset - 1, "right", ACTION_STATES.MV, c_moveLine)
    const attackButton = new ActionPopup("Attack", 0, "center", ACTION_STATES.ATK, c_atkTarget)
    const giveButton = new ActionPopup("Support", xOffset, "left", ACTION_STATES.GV, c_giveLine)

    const actionPopups = [ moveButton, attackButton, giveButton ]

    guiDriver.components.push(...actionPopups)

    // Action guis

    // Move gui
    const moveGui = new class extends Driver.ActiveComponent {
        constructor() {
            super();

            this.confirming = false;

            if (userTank)
                this.init()
        }

        init() {
            this.boxes = [ userTank.box ]; // Path from selected grid
            this.hintBoxes = [ userTank.box ]; // Show path on hover

            this.destinations = [] // Stop points of selected grid
        }

        confirmMove() {
            if (this.confirming) return;
            actionState = ACTION_STATES.SELECT

            // Remove first position (which is the player's current position)
            const positions = this.boxes.slice(1, this.boxes.length).map(box => box.coords)

            userPlayer.position = positions[positions.length - 1]
            userTank.move(positions[positions.length - 1])

            this.init()
            this.confirming = true;


            fetch(`/action/${ game._id }/move`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ positions: positions })
            })
                .then(() => {
                    console.log("Success!")
                    refetch()
                    this.init()
                    this.confirming = false;
                })
        }

        cancel() {
            actionState = ACTION_STATES.SELECT
            this.init()
            actions = userPlayer.actions
            updateInfo()
        }

        getCurrentBox = () => this.boxes[this.boxes.length - 1]

        update(driver) {
            if (actionState !== ACTION_STATES.MV) return;

            if (this.confirming) return;

            if (driver.key_events["Escape"]) {
                this.cancel()
            }

            const MOVE = {
                CONFIRM: 0,
                REMOVE: 1,
                ADD: 2,
                RESET: 3,
                CANCEL: 4,
                COLLIDE: 5
            }

            let moveType;

            // Existing spot
            if (this.destinations.includes(hoveredBox)) {
                // Final spot
                if (this.destinations.indexOf(hoveredBox) === this.destinations.length - 1) {
                    updateHint("Move", `[${ getChar(hoveredBox.coords.x) }${ hoveredBox.coords.y + 1 }] ` + "Press 'Enter' or click again to commit movement", "Press escape to cancel" , c_moveLine)
                    moveType = MOVE.CONFIRM
                } else {
                    updateHint("Move", "Click to remove succeeding waypoints", "Press escape to cancel")
                    moveType = MOVE.REMOVE
                }

                // Reset
            } else if (hoveredBox === userTank.box) {
                if (this.boxes.length === 1) {
                    updateHint("Move", "Press 'Escape' or click to cancel movement")
                    moveType = MOVE.CANCEL
                } else {
                    updateHint("Move", "Click to remove succeeding waypoints", "Press escape to cancel")
                    moveType = MOVE.RESET
                }
                // New spot
            } else {
                if (!game.players.find(player => coordsEquals(player.position, hoveredBox.coords))) {
                    updateHint("Move", `[${ getChar(hoveredBox.coords.x) }${ hoveredBox.coords.y + 1 }] ` + "Click to add waypoint", "Press escape to cancel")
                    moveType = MOVE.ADD;
                } else {
                    updateHint("Move", "Can't move there!")
                    moveType = MOVE.COLLIDE;
                }
            }


            if (driver.mouse_events.pressed || driver.key_pressed["Enter"]) {
                switch (moveType) {
                    case MOVE.ADD:
                        // Parallel position
                        if (parallelCoords(this.getCurrentBox().coords, hoveredBox.coords)) {
                            getPath(this.getCurrentBox().coords, hoveredBox.coords).forEach(c => this.boxes.push(grid[c.x][c.y]))
                        } else {
                            // Elbow position
                            const elbowCoords = connectCoords(this.getCurrentBox().coords, hoveredBox.coords);

                            getPath(this.getCurrentBox().coords, elbowCoords).forEach(c => this.boxes.push(grid[c.x][c.y]))
                            getPath(elbowCoords, hoveredBox.coords).forEach(c => this.boxes.push(grid[c.x][c.y]))
                        }

                        // Overflow
                        if (this.boxes.length > userPlayer.actions + 1) {
                            this.boxes = this.boxes.slice(0, userPlayer.actions + 1)
                            if (this.boxes.length > 1)
                                this.destinations.push(this.getCurrentBox())
                        } else {
                            this.destinations.push(hoveredBox)
                        }
                        break;
                    case MOVE.RESET:
                        this.init()
                        break;
                    case MOVE.CANCEL:
                        this.cancel()
                        break;
                    case MOVE.CONFIRM:
                        this.confirmMove();
                        break;
                    case MOVE.REMOVE:
                        this.destinations = this.destinations.slice(0, this.destinations.indexOf(hoveredBox) + 1)
                        this.boxes = this.boxes.slice(0, this.boxes.indexOf(this.destinations[this.destinations.length - 1]) + 1)
                        if (this.destinations.length === 0) {
                            this.boxes = [ userTank.box ];
                        }
                        break;
                }

            }

            this.hintBoxes = [];

            const elbowCoords = connectCoords(this.getCurrentBox().coords, hoveredBox.coords);

            getPath(this.getCurrentBox().coords, elbowCoords).forEach(c => this.hintBoxes.push(grid[c.x][c.y]))
            getPath(elbowCoords, hoveredBox.coords).forEach(c => this.hintBoxes.push(grid[c.x][c.y]))
        }

        drawDest(ctx, box) {
            ctx.strokeStyle = 'white'
            ctx.strokeRect(box.x + GRID_SIZE / 4, box.y + GRID_SIZE / 4, box.width - GRID_SIZE / 2, box.height - GRID_SIZE / 2)
        }

        drawCancel(ctx, box) {
            ctx.strokeStyle = 'white'
            ctx.beginPath()
            ctx.moveTo(box.x + GRID_SIZE / 4, box.y + GRID_SIZE / 4)
            ctx.lineTo(box.x + GRID_SIZE / 4 + box.width - GRID_SIZE / 2, box.y + GRID_SIZE / 4 + box.height - GRID_SIZE / 2)
            ctx.moveTo(box.x + GRID_SIZE / 4, box.y + GRID_SIZE / 4 + box.height - GRID_SIZE / 2)
            ctx.lineTo(box.x + GRID_SIZE / 4 + box.width - GRID_SIZE / 2, box.y + GRID_SIZE / 4)

            ctx.stroke()
        }

        drawConfirm(ctx, box) {
            ctx.strokeStyle = c_moveLine
            ctx.beginPath()
            ctx.arc(center(box).x, center(box).y, GRID_SIZE / 4, 0, 2 * Math.PI)
            ctx.closePath()
            ctx.stroke()
        }

        redraw(driver) {
            if (actionState !== ACTION_STATES.MV) return;

            const ctx = driver.canvas_ctx;

            ctx.strokeStyle = '#ffffff'

            const path = [ ...this.boxes, ...this.hintBoxes ]

            let onDest = false;

            for (let i = 0; i < path.length; i++) {
                // Fill path boxes' color
                if (onDest || hoveredBox === userTank.box) {
                    ctx.fillStyle = c_moveCancel
                } else if (game.players.find(player => coordsEquals(player.position, hoveredBox.coords))) {
                    ctx.fillStyle = c_moveOutOfRange
                } else {
                    ctx.fillStyle = i < userPlayer.actions + 1 ? c_moveBlock : c_moveOutOfRange
                }

                ctx.fillRect(path[i].x, path[i].y, path[i].width, path[i].height)

                if (this.destinations.includes(path[i])) {
                    // Draw marks for destinations
                    if (onDest || hoveredBox === userTank.box) {
                        this.drawCancel(ctx, path[i])
                    } else if (i === this.boxes.length - 1 && hoveredBox === this.destinations[this.destinations.length - 1]) {
                        this.drawConfirm(ctx, path[i]);
                    } else {
                        this.drawDest(ctx, path[i]);
                    }

                    // If current box is the hovered box and it's not the final destination (in which we confirm instead of cancel)
                    //  or its the first box
                    if ((hoveredBox === path[i] && this.destinations.indexOf(path[i]) !== this.destinations.length - 1)
                        || hoveredBox === userTank.box) {
                        onDest = true;
                    }
                }

                // Skip hover if cancelling
                if (onDest && i === this.boxes.length - 1) break;
            }

            const arrowHeadLength = 10

            // Mark targets
            game.players
                .filter(player => inRange(hoveredBox.coords, player.position, userPlayer.range + giveRangeIncrease) && player !== userPlayer)
                .map(player => tanks.find(t => coordsEquals(t.box.coords, player.position)))
                .forEach(tank => {
                    if (tank.box === hoveredBox) return

                    if (inRange(hoveredBox.coords, tank.box.coords, userPlayer.range)) {
                        ctx.strokeStyle = c_atkRange
                    } else {
                        ctx.strokeStyle = c_giveRange
                    }

                    const angle = angleTo(hoveredBox, tank.box)
                    const origin = vecToPoint(5, angle - Math.PI / 2)
                    const arrowHead = vecToPoint(arrowHeadLength, angle - Math.PI / 2 - Math.PI / 4)

                    ctx.beginPath()
                    ctx.moveTo(center(hoveredBox).x + origin.x, center(hoveredBox).y + origin.y)
                    ctx.lineTo(center(tank.box).x + origin.x, center(tank.box).y + origin.y)
                    ctx.lineTo(center(tank.box).x + origin.x + arrowHead.x, center(tank.box).y + origin.y + arrowHead.y)
                    ctx.stroke();
                })

            // Enemy range warning
            game.players
                .forEach(p => {
                    if (p._id === userPlayer._id) return;
                    const tank = tanks.find(t => coordsEquals(t.box.coords, p.position));
                    if (tank.box === hoveredBox) return

                    if (inRange(tank.box.coords, hoveredBox.coords, p.range)) {
                        ctx.strokeStyle = c_atkRange
                    } else if (inRange(tank.box.coords, hoveredBox.coords, p.range + giveRangeIncrease)) {
                        ctx.strokeStyle = c_giveRange
                    } else {
                        return
                    }

                    const angle = angleTo(hoveredBox, tank.box)
                    const origin = vecToPoint(2, angle + Math.PI / 2)
                    const arrowHead = vecToPoint(arrowHeadLength, angle + Math.PI / 4)

                    ctx.beginPath()
                    ctx.moveTo(center(tank.box).x + origin.x, center(tank.box).y + origin.y)
                    ctx.lineTo(center(hoveredBox).x + origin.x, center(hoveredBox).y + origin.y)
                    ctx.lineTo(center(hoveredBox).x + origin.x + arrowHead.x, center(hoveredBox).y + origin.y + arrowHead.y)
                    ctx.stroke();
                })

            actions = userPlayer.actions - path.length + 1
            updateInfo()
        }
    }


    // Attack gui
    const attackGui = new class extends Driver.ActiveComponent {
        constructor(props) {
            super(props);
            /**
             * @type {Tank[]}
             */
            this.targets = [];
            this.hoverOnSelectedTarget = false;
            this.confirming = false;

            if (userTank)
                this.init();
        }

        init() {
            this.targets = game.players
                .filter(player => inRange(userTank.box.coords, player.position, userPlayer.range) && player !== userPlayer)
                .map(player => tanks.find(t => coordsEquals(t.box.coords, player.position)))

            /**
             * @type {Tank}
             */
            this.selectedTarget = null;
        }

        confirm() {
            console.log("Attacking...")
            selectedTank === userTank
            fetch(`/action/${ game._id }/attack/${ this.selectedTarget.player._id }`, { method: 'POST' })
                .then(() => {
                    console.log("Attack success")
                })
                .catch(e => {
                    console.log(e)
                })
                .finally(() => {
                    refetch()
                    this.cancel()
                })
        }

        cancel() {
            this.init();
            actionState = ACTION_STATES.SELECT
            updateInfo()
            this.confirming = false;
            document.body.className = ''
        }

        update(driver) {
            if (actionState !== ACTION_STATES.ATK) return;
            if (this.confirming) {
                updateHint("Attack", "Engaging...", "." , c_atkMarkedTarget)
                return
            }

            updateInfo()

            actions = userPlayer.actions

            if (driver.key_pressed["Escape"]) this.cancel()

            const ATTACK = {
                NONE: -1,
                HOVER: 0,
                ATTACK: 1
            }

            let attackState = ATTACK.NONE

            const hoverTarget = this.targets.find(t => hoveredBox === t.box)

            this.hoverOnSelectedTarget = false;
            if (!this.selectedTarget) {
                if (hoverTarget) {
                    updateHint("Attack", "Click to mark target")
                    attackState = ATTACK.HOVER
                } else {
                    updateHint("Attack", "Click on a tank to mark as target", "Press escape to cancel")
                }
            } else {
                if (this.selectedTarget === hoverTarget) {
                    updateHint("Attack", "Click to commence attack on " + this.selectedTarget.player.name, "Press escape to cancel" , c_atkMarkedTarget)
                    this.hoverOnSelectedTarget = true;
                    actions = userPlayer.actions - 1
                    updateInfo()
                    attackState = ATTACK.ATTACK
                } else {
                    updateHint("Attack", "Click to remove mark")
                    attackState = ATTACK.NONE
                }
            }


            if (driver.mouse_events.pressed) {
                switch (attackState) {
                    case ATTACK.NONE:
                        this.selectedTarget = null
                        break;
                    case ATTACK.HOVER:
                        this.selectedTarget = hoverTarget;
                        break;
                    case ATTACK.ATTACK:
                        this.confirm();
                        this.confirming = true;
                        document.body.className = 'waiting'
                        break;
                    default:
                }
            }
        }

        markTargets(ctx, box, color = c_atkTarget) {
            if (this.confirming) {
                ctx.fillStyle = c_atkConfirming
                ctx.fillRect(box.x, box.y, box.width, box.height)
                return;
            }

            ctx.strokeStyle = color;
            ctx.shadowColor = 'white'
            ctx.shadowBlur = 3

            const innerRadius = 5;
            const outerRadius = 17;
            const lineLength = 5;

            ctx.beginPath()
            ctx.arc(center(box).x, center(box).y, innerRadius, 0, 2 * Math.PI)
            ctx.closePath();
            ctx.stroke()

            ctx.beginPath()
            ctx.arc(center(box).x, center(box).y, outerRadius, -Math.PI / 4, Math.PI / 4)
            ctx.stroke()

            ctx.beginPath()
            ctx.arc(center(box).x, center(box).y, outerRadius, Math.PI * 3 / 4, -Math.PI * 3 / 4)
            ctx.stroke()

            ctx.moveTo(center(box).x, center(box).y + outerRadius)
            ctx.lineTo(center(box).x, center(box).y + outerRadius + lineLength)
            ctx.moveTo(center(box).x, center(box).y - outerRadius)
            ctx.lineTo(center(box).x, center(box).y - outerRadius - lineLength)

            ctx.moveTo(center(box).x + outerRadius, center(box).y)
            ctx.lineTo(center(box).x + outerRadius + lineLength, center(box).y)
            ctx.moveTo(center(box).x - outerRadius, center(box).y)
            ctx.lineTo(center(box).x - outerRadius - lineLength, center(box).y)
            ctx.stroke()

            ctx.shadowBlur = 0
        }

        redraw(driver) {
            if (actionState !== ACTION_STATES.ATK) return;
            const ctx = driver.canvas_ctx;

            this.targets.forEach(t => {
                if (this.selectedTarget && t === this.selectedTarget) {
                    this.markTargets(ctx, t.box, c_atkMarkedTarget)
                } else {
                    this.markTargets(ctx, t.box)
                }

            })


        }
    }

    // Give gui
    giveGui = new class extends Driver.ActiveComponent {
        constructor(props) {
            super(props);
            /**
             * @type {Tank[]}
             */
            this.targets = [];
            this.hoverOnSelectedTarget = false;
            this.confirming = false;

            if (userTank)
                this.init();
        }

        init() {
            this.targets = game.players
                .filter(player => inRange(userTank.box.coords, player.position, userPlayer.range + giveRangeIncrease) && player !== userPlayer)
                .map(player => tanks.find(t => coordsEquals(t.box.coords, player.position)))

            /**
             * @type {Tank}
             */
            this.selectedTarget = null;
        }

        confirm() {
            console.log("Giving...")
            selectedTank === userTank

            fetch(`/action/${ game._id }/give/${ this.selectedTarget.player._id }/actions/1`, { method: 'POST' })
                .then(() => {
                    console.log("Giving success")
                    refetch()
                    this.cancel()
                })
        }

        cancel() {
            this.init();
            actionState = ACTION_STATES.SELECT
            updateInfo()
            this.confirming = false;
            document.body.className = ''
        }

        update(driver) {
            if (actionState !== ACTION_STATES.GV) return;
            if (this.confirming) {
                updateHint("Support", "Awaiting response")
                return;
            }

            updateInfo()

            actions = userPlayer.actions

            if (driver.key_pressed["Escape"]) this.cancel()

            const SUPPORT = {
                NONE: -1,
                HOVER: 0,
                ATTACK: 1
            }

            let supportState = SUPPORT.NONE

            const hoverTarget = this.targets.find(t => hoveredBox === t.box)

            this.hoverOnSelectedTarget = false;
            if (!this.selectedTarget) {
                if (hoverTarget) {
                    updateHint("Support", "Click to select recipient")
                    supportState = SUPPORT.HOVER
                } else {
                    updateHint("Support", "Click on a tank to set as recipient", "Press escape to cancel")
                }
            } else {
                if (this.selectedTarget === hoverTarget) {
                    updateHint("Support", "Click to send energy points", "Press escape to cancel", c_giveLine)
                    this.hoverOnSelectedTarget = true;
                    actions = userPlayer.actions - 1
                    updateInfo()
                    supportState = SUPPORT.ATTACK
                } else {
                    updateHint("Support", "Click to deselect recipient")
                    supportState = SUPPORT.NONE
                }
            }


            if (driver.mouse_events.pressed) {
                switch (supportState) {
                    case SUPPORT.NONE:
                        this.selectedTarget = null
                        break;
                    case SUPPORT.HOVER:
                        this.selectedTarget = hoverTarget;
                        break;
                    case SUPPORT.ATTACK:
                        this.confirm();
                        this.confirming = true;
                        document.body.className = 'waiting'
                        break;
                    default:
                }
            }
        }

        markTargets(ctx, box, color = 'white') {
            if (this.confirming) {
                ctx.fillStyle = c_giveConfirming
                ctx.fillRect(box.x, box.y, box.width, box.height)
                return;
            }
            ctx.strokeStyle = color;
            ctx.shadowColor = 'white'
            ctx.shadowBlur = 3

            const innerRadius = 5;
            const outerRadius = 17;

            ctx.beginPath()
            ctx.arc(center(box).x, center(box).y, innerRadius, 0, 2 * Math.PI)
            ctx.closePath();
            ctx.stroke()

            ctx.beginPath()
            ctx.arc(center(box).x, center(box).y, outerRadius, 0, 2 * Math.PI)
            ctx.stroke()


            ctx.shadowBlur = 0
        }

        redraw(driver) {
            if (actionState !== ACTION_STATES.GV) return;
            const ctx = driver.canvas_ctx;

            this.targets.forEach(t => {
                if (this.selectedTarget && t === this.selectedTarget) {
                    this.markTargets(ctx, t.box, c_giveLine)
                } else {
                    this.markTargets(ctx, t.box)
                }

            })


        }
    }


    actionGuis = [ moveGui, attackGui, giveGui ]

    if (userTank)
        guiDriver.components.push(...actionGuis)


    // Selection
    guiDriver.components.push(new class extends Driver.ActiveComponent {
        constructor() {
            super();
            this.animationIndex = 0;
        }

        update = () => {
            this.x = hoveredBox.x;
            this.y = hoveredBox.y;
            this.width = GRID_SIZE;
            this.height = GRID_SIZE;

            this.animationIndex += 0.25;
            if (this.animationIndex >= 20) this.animationIndex = 0

            if (actionState === ACTION_STATES.SELECT) updateHint("Coordinate:", `${ getChar(hoveredBox.coords.x) }${ hoveredBox.coords.y + 1 }`)

        }

        redraw = driver => {
            if (focused) {
                focused = false;
                return
            }

            const ctx = driver.canvas_ctx;

            ctx.beginPath()
            if (this.animationIndex < 10) {
                ctx.moveTo(this.x, this.y)
                ctx.lineTo(this.x + (this.width / 10) * this.animationIndex, this.y)

                ctx.moveTo(this.x + this.width, this.y + this.height)
                ctx.lineTo(this.x - (this.width / 10) * this.animationIndex + this.width, this.y + this.height)

                // y
                ctx.moveTo(this.x + this.width, this.y + (this.height / 10) * (this.animationIndex))
                ctx.lineTo(this.x + this.width, this.y + this.height)

                ctx.moveTo(this.x, this.y + this.height - (this.width / 10) * (this.animationIndex))
                ctx.lineTo(this.x, this.y)
            } else {
                ctx.moveTo(this.x + (this.width / 10) * (this.animationIndex - 10), this.y)
                ctx.lineTo(this.x + this.width, this.y)

                ctx.moveTo(this.x + this.width - (this.width / 10) * (this.animationIndex - 10), this.y + this.height)
                ctx.lineTo(this.x, this.y + this.height)

                // y
                ctx.moveTo(this.x + this.width, this.y)
                ctx.lineTo(this.x + this.width, this.y + (this.height / 10) * (this.animationIndex - 10))

                ctx.moveTo(this.x, this.y + this.height)
                ctx.lineTo(this.x, this.y + this.height - (this.height / 10) * (this.animationIndex - 10))
            }

            disableUpgrades()

            ctx.lineWidth = 2;
            switch (actionState) {
                case ACTION_STATES.MV:
                    ctx.strokeStyle = c_moveLine
                    break;
                case ACTION_STATES.ATK:
                    if (attackGui.selectedTarget && attackGui.hoverOnSelectedTarget) {
                        ctx.strokeStyle = c_atkMarkedTarget
                    } else {
                        ctx.strokeStyle = c_atkTarget
                    }
                    break;
                case ACTION_STATES.GV:
                    ctx.strokeStyle = c_giveLine
                    break;
                default:
                    ctx.strokeStyle = 'white'
                    if (selectedTank === userTank) {
                        if (hoveredBox === userTank.box) {
                            if (userPlayer.actions > 0) {
                                updateHint("Control", "Click to toggle controls")
                            } else {
                                updateHint("Control", "Out of energy!", '.', 'red')
                                showPlayerOption = false;
                            }
                        }

                        enableUpgrades()
                    }
            }

            ctx.stroke()
        }
    })

    backgroundDriver.run(10);
    objectDriver.run(16);
    guiDriver.run(16)

    updateInfo()

    function updateInfo() {
        // Info panel
        const player = selectedTank.player;
        const isUser = userTank === selectedTank

        document.querySelector('#name').innerHTML = player.name
        document.querySelector('#id').innerHTML = ` &lt${ getChar(player.position.x) }${ player.position.y + 1 }&gt ${ player._id }`
        document.querySelector('#actions').innerHTML = "Energy: " + player.actions + (isUser && actions !== player.actions ? ` → ${ actions }` : '')
        if (player.actions === 0) {
            document.querySelector('#actions').style.color = 'red'
        } else {
            document.querySelector('#actions').style.color = 'white'
        }

        document.querySelector('#health').innerHTML = "Health: " + player.health
        document.querySelector('#range').innerHTML = "Range: " + player.range
    }

    function updateHint(title, text, minorHint = ".", color = 'white') {
        if (!title) {
            document.querySelector('#hintPanel').style.display = 'none';
        }

        document.querySelector('#hintPanel').style.display = 'block';
        document.querySelector('#hintPanel h3').innerHTML = title;
        document.querySelector('#hintPanel p').innerHTML = text;

        document.querySelector('#hintPanel #minorHint').innerHTML = minorHint
        if (minorHint === ".") {
            document.querySelector('#hintPanel #minorHint').classList.add("hidden")
        } else {
            document.querySelector('#hintPanel #minorHint').classList.remove("hidden")
        }

        document.querySelector('#hintPanel h3').style.color = color;
    }

    let actionsToAdd = {}


    function disableUpgrades() {
        upgradeButtons.forEach(a => a.classList.add('disabled'))
    }

    function enableUpgrades() {
        upgradeButtons.forEach(a => a.classList.remove('disabled'))
    }

    document.querySelectorAll("#infoPanel .upgrade").forEach(node => {
        const upgradeName = node.dataset.upgrade;
        const actionCost = parseInt(node.dataset.cost);

        upgradeButtons.push(node.querySelector("a.plus"))
        upgradeButtons.push(node.querySelector("a.minus"))
        upgradeButtons.push(document.querySelector("a.cancel"))
        upgradeButtons.push(document.querySelector("a.confirm"))

        node.querySelector("a.plus").onclick = () => {
            if (node.querySelector("a.plus").classList.contains("disabled")) return;

            if (actions - actionCost < 0) return;

            if (actionsToAdd[upgradeName]) {
                actionsToAdd[upgradeName] += 1;
                actions -= actionCost
            } else {
                actionsToAdd[upgradeName] = 1;
                actions -= actionCost
            }

            node.querySelector(".actionsToAdd").innerHTML = actionsToAdd[upgradeName] > 0 ? `+${ actionsToAdd[upgradeName] }` : ''
            updateInfo()
        }

        node.querySelector("a.minus").onclick = () => {
            if (node.querySelector("a.minus").classList.contains("disabled")) return;

            if (actionsToAdd[upgradeName] !== undefined) {
                if (actionsToAdd[upgradeName] > 0) {
                    actionsToAdd[upgradeName] -= 1;
                    actions += actionCost
                }
            } else {
                actionsToAdd[upgradeName] = 0;
            }

            node.querySelector(".actionsToAdd").innerHTML = actionsToAdd[upgradeName] > 0 ? `+${ actionsToAdd[upgradeName] }` : ''
            updateInfo()
        }
    })

    document.querySelector("#infoPanel .cancel").onclick = () => {
        if (document.querySelector("a.cancel").classList.contains("disabled")) return;
        Object.keys(actionsToAdd).forEach(k => {
            actions += actionsToAdd[k]
            actionsToAdd[k] = 0
        })

        document.querySelectorAll('.actionsToAdd').forEach(n => n.innerHTML = '')
        updateInfo()
    }

    document.querySelector("#infoPanel .confirm").onclick = () => {
        if (document.querySelector("a.cancel").classList.contains("disabled")) return;

        disableUpgrades()

        const fetchPromises = Object.keys(actionsToAdd).map(k =>
            fetch(`/action/${ game._id }/upgrade/${ k }/count/${ actionsToAdd[k] }`, { method: 'POST' })
        )

        Promise.all(fetchPromises).then(() => {
            updateInfo()
            enableUpgrades()
            refetch()
        })

        document.querySelectorAll('.actionsToAdd').forEach(n => n.innerHTML = '')
        updateInfo()
    }
</script>

<%- include('../../partials/footer.html') %>
</body>

<style>
    html, body {
        background-color: black;
        max-height: fit-content;
        padding-bottom: 40px;
    }

    #statsPanel {
        position: absolute;
        margin: 10px;
    }

    .panel {
        padding: 15px;
        margin: 15px 30px 15px 15px;

        border: rgba(158, 202, 237, 0.69) solid 1px;
        box-shadow: 0 0 10px rgba(158, 202, 237, 0.45);
    }

    #infoPanel {
        position: fixed;
        right: 0;
    }

    #infoPanel h3 {
        margin-bottom: 0;
    }

    #infoPanel #id {
        margin-top: 5px;
        font-size: 10px;
        color: #fffc4d;
    }

    #infoPanel p {
        color: #b6dad7;
    }

    #hintPanel {
        position: fixed;
        right: 0;
        bottom: 0;
        display: none;

        z-index: 300;
    }

    #hintPanel h3 {
        margin-bottom: 0;
    }

    #hintPanel p {
        margin-top: 7px;
        margin-bottom: 0;
        font-size: 16px;
    }

    #hintPanel #minorHint {
        margin-top: 0;
        margin-bottom: 0;
        color: gray;
        font-size: 12px;
    }

    #hintPanel #minorHint.hidden {
        color: black;
    }

    #winScreen {
        display: none;
        position: fixed;
        left: 50%;
        bottom: 50%;
        transform: translateX(-50%);
        background-color: black
    }

    #infoPanel a {
        font-size: 16px;
        display: inline-block;
        -webkit-user-select: none; /* Safari */
        -moz-user-select: none; /* Firefox */
        -ms-user-select: none; /* IE10+/Edge */
        user-select: none; /* Standard */
    }

    #infoPanel a.disabled {
        color: gray;
        cursor: default;
    }

    .upgrade {
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .confirm {
        display: flex;
        justify-content: flex-end;
    }
</style>